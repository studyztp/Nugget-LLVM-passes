# PhaseAnalysisPass Test Suite

This directory contains tests for the **PhaseAnalysisPass**, which instruments LLVM IR with runtime hooks for phase-based analysis.

## Overview

The PhaseAnalysisPass performs the following transformations on LLVM IR:

1. **Inserts `nugget_init_` call**: At the start of `nugget_roi_begin_`, it inserts a call to `nugget_init_(total_bb_count)` to initialize the runtime with the total number of basic blocks.

2. **Instruments all basic blocks**: Every basic block that has `!bb.id` metadata (from IRBBLabelPass) gets a `nugget_bb_hook_(function_id, bb_id, interval_length)` call inserted at its entry point.

3. **Skips nugget functions**: Functions like `nugget_init_`, `nugget_roi_begin_`, `nugget_roi_end_`, and `nugget_bb_hook_` are not instrumented to avoid infinite recursion.

## Prerequisites

Before running these tests, ensure:

1. **NuggetPasses.so is built**:
   ```bash
   cd ../../pass
   mkdir -p build && cd build
   cmake .. -DLLVM_DIR=/usr/lib/llvm-18/lib/cmake/llvm
   make
   ```

2. **LLVM 18 tools are available**:
   - clang, clang++, opt, llvm-dis, llvm-link

## Building the Tests

```bash
mkdir -p build && cd build
cmake .. \
  -DLLVM_BIN_DIR=/usr/lib/llvm-18/bin \
  -DPASS_PLUGIN=../../pass/build/NuggetPasses.so
make
```

### CMake Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `LLVM_BIN_DIR` | Path to LLVM bin directory | `/usr/lib/llvm-18/bin` |
| `PASS_PLUGIN` | Path to NuggetPasses.so | `../../pass/build/NuggetPasses.so` |

## Running the Tests

```bash
cd build
ctest --output-on-failure
```

Or run a specific test:
```bash
ctest -R test1_simple -V
```

## Test Structure

```
PhaseAnalysisPass-test/
├── CMakeLists.txt           # Main CMake configuration
├── README.md                # This file
├── common/
│   ├── nugget_runtime.c     # Stub implementations of runtime functions
│   ├── verify_instrumentation.py  # Python validation for test1 (IR only)
│   └── verify_machine_match.py    # Python validation for test2 (IR ↔ ASM, multi-arch)
├── test1_simple/
│   ├── CMakeLists.txt       # Test-specific build configuration
│   └── test1_simple.c       # Test source code
└── test2_machine_match/
    ├── CMakeLists.txt       # Full pipeline build configuration
    └── test2_machine_match.c # Complex test program
```

## Test Cases

### test1_simple

Basic instrumentation test that verifies:
- `nugget_init_` is called with the correct total BB count
- All labeled basic blocks have `nugget_bb_hook_` calls
- Hook calls receive correct bb_inst_count, bb_id, and interval_length arguments

**Compilation Pipeline:**
1. Compile test source to LLVM IR (`-O0 -Xclang -disable-O0-optnone`)
2. Compile runtime to LLVM IR
3. Link test and runtime IR with `llvm-link`
4. Apply `-O2` optimizations with `opt`
5. Run `IRBBLabelPass` to label all basic blocks
6. Run `PhaseAnalysisPass` to instrument basic blocks
7. Convert to readable IR for verification

### test2_machine_match

Full compilation pipeline test that verifies IR basic blocks map correctly to machine code:

**Features tested:**
- Multiple functions with different control flow patterns
- Nested loops
- Switch statements
- Function calls
- Conditional branches

**Compilation Pipeline:**
1. Compile test source to LLVM IR (`-O0 -Xclang -disable-O0-optnone`)
2. Compile runtime to LLVM IR
3. Link test and runtime IR with `llvm-link`
4. Apply `-O2` optimizations with `opt`
5. Run `IRBBLabelPass` to label all basic blocks
6. Run `PhaseAnalysisPass` to instrument basic blocks
7. Compile to object file with `llc -O2 -relocation-model=pic`
8. Link to executable with `clang`
9. Disassemble with `objdump`
10. Verify IR hooks match machine code hooks

**Validations:**
- CSV file exists with correct format
- Executable runs without crashing
- `nugget_init_` call appears in `nugget_roi_begin_`
- `nugget_bb_hook_` calls appear in the disassembly
- IR hooks match machine code hooks by (inst_count, bb_id, interval) tuples
- Supports both x86-64 and AArch64 architectures

## Common Directory

### nugget_runtime.c

Contains stub implementations for runtime functions:

```c
void nugget_init_(uint64_t total_bb_count);
void nugget_roi_begin_(void);
void nugget_roi_end_(void);
void nugget_bb_hook_(uint64_t function_id, uint64_t bb_id, uint64_t interval_length);
```

These are placeholder implementations used during IR generation. In a real deployment, these would be replaced with actual instrumentation runtime code.

### verify_instrumentation.py

Python script that validates the instrumented IR for test1:

1. **Parses the CSV file** generated by IRBBLabelPass to get expected BB IDs
2. **Checks `nugget_init_` call**: Verifies it exists in `nugget_roi_begin_` with correct argument
3. **Checks `nugget_bb_hook_` calls**: Verifies each labeled BB has a hook call with matching IDs
4. **Reports errors** if instrumentation is missing or incorrect

Usage:
```bash
python3 verify_instrumentation.py <instrumented.ll> <bb_info.csv> <interval_length>
```

### verify_machine_match.py

Python script that validates IR-to-machine-code mapping for test2. Supports **x86-64** and **AArch64** architectures.

**Features:**
1. **Auto-detects architecture** from objdump output format header
2. **Parses the CSV file** to get valid BB IDs
3. **Parses the instrumented IR** to extract hook calls with parameters
4. **Parses the disassembly** to extract hook calls with register-based arguments
5. **Verifies `nugget_init_` call** appears in `nugget_roi_begin_`
6. **Compares IR and ASM hooks** by matching (inst_count, bb_id, interval) tuples

**Architecture Support:**

| Feature | x86-64 | AArch64 |
|---------|--------|---------|
| Arg1 (inst_count) | `edi`/`rdi` | `w0`/`x0` |
| Arg2 (bb_id) | `esi`/`rsi` | `w1`/`x1` |
| Arg3 (interval) | `edx`/`rdx` | `w2`/`x2` |
| Load immediate | `mov $imm,%reg` | `mov/movz reg, #imm` |
| Zero register | `xor %reg,%reg` | `mov reg, #0` |
| Call pattern | `call <target>` | `bl <target>` |
| Branch patterns | `jmp`, `jXX` | `b`, `b.XX` |

**Architecture Detection:**
- `elf64-x86-64` → X86_64Handler
- `elf64-littleaarch64` → AArch64Handler

Usage:
```bash
python3 verify_machine_match.py <instrumented.ll> <disassembly.txt> <bb_info.csv> <interval_length>
```

## Pass Parameters

The PhaseAnalysisPass accepts the following parameter:

| Parameter | Description | Default |
|-----------|-------------|---------|
| `interval_length` | Sampling interval for phase analysis | 1000 |

Example usage in opt:
```bash
opt -load-pass-plugin=NuggetPasses.so \
    -passes="phase-analysis-pass<interval_length=5000>" \
    input.bc -o output.bc
```

## Expected IR Transformations

### Before PhaseAnalysisPass

```llvm
define void @nugget_roi_begin_() {
entry:
  ret void
}

define i32 @compute(i32 %n) {
entry:
  ; ... computation ...
  ret i32 %result, !bb.id !0
}

!0 = !{!"compute:0:entry"}
```

### After PhaseAnalysisPass

```llvm
define void @nugget_roi_begin_() {
entry:
  call void @nugget_init_(i64 42)  ; 42 = total BB count from CSV
  ret void
}

define i32 @compute(i32 %n) {
entry:
  call void @nugget_bb_hook_(i64 5, i64 0, i64 1000)  ; bb_inst_count=5, bb_id=0, interval=1000
  ; ... computation ...
  ret i32 %result, !bb.id !0
}
```

## Hook Function Signature

The `nugget_bb_hook_` function signature is:
```c
void nugget_bb_hook_(uint64_t bb_inst_count, uint64_t bb_id, uint64_t interval_length);
```

Where:
- `bb_inst_count`: Number of LLVM IR instructions in this basic block
- `bb_id`: Global basic block ID from the CSV (unique across the module)
- `interval_length`: Sampling interval for phase analysis

## Troubleshooting

### "Pass plugin not found"
Ensure you've built NuggetPasses.so and the path is correct:
```bash
ls -la ../../pass/build/NuggetPasses.so
```

### "clang not found"
Verify LLVM_BIN_DIR points to a valid LLVM installation:
```bash
ls /usr/lib/llvm-18/bin/clang
```

### "nugget_roi_begin_ not found"
The test source must include a call to `nugget_roi_begin_()` for the pass to have a function to instrument.

### Python verification fails
Check the generated files:
```bash
cat build/test1_simple/bb_info.csv
cat build/test1_simple/test1_instrumented.ll
```

### "Unknown architecture" error
The verify_machine_match.py script auto-detects the architecture from the disassembly header.
Supported formats:
- `elf64-x86-64` (x86-64 Linux)
- `elf64-littleaarch64` (AArch64 Linux)

If you're targeting a different platform, you may need to extend the script with a new architecture handler.

## Adding New Tests

1. Create a new directory: `test2_newfeature/`
2. Add source file: `test2_newfeature.c`
3. Add CMakeLists.txt following the pattern from test1_simple
4. Add the subdirectory in the main CMakeLists.txt:
   ```cmake
   add_subdirectory(test2_newfeature)
   ```

## License

SPDX-License-Identifier: BSD-3-Clause

Copyright (c) 2026 Zhantong Qiu. All rights reserved.
